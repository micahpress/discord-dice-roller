import discord
import re
import os
from dotenv import load_dotenv
from discord.ext import commands
from RollParams import RollParams
from RollResult import RollResult
from Advantage import Advantage
from typing import Optional

config_path = os.path.join(os.getcwd(), "config.env")
load_dotenv(config_path)
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")

help_cmd = commands.DefaultHelpCommand(no_category='Commands')

bot = commands.Bot(command_prefix='?', help_command=help_cmd)


'''
Attempts to validate and parse a string representing a dice roll 
of the form <quantity>d<sides>+<modifier>. Returns an Optional[RollParams] 
object.
'''
def parse_roll_string(roll_string: str) -> Optional[RollParams]:
    roll_string_pattern: re.Pattern = re.compile(r"(?P<quantity>\d+)(\s*d\s*)(?P<sides>\d+)\s*((?P<mod_sign>\+|-)\s*(?P<modifier>\d+)|$)")
    maybe_valid_roll = re.match(roll_string_pattern, roll_string)

    if not maybe_valid_roll:
        return None
    
    groups = maybe_valid_roll.groupdict()

    return RollParams(int(groups['quantity']), int(groups['sides']), int(groups['modifier']) if groups['modifier'] else None, groups['mod_sign'])

'''
Creates and returns a RollResult object from a given RollParams object.
'''
def make_roll(roll_params: RollParams) -> RollResult:
    return RollResult(roll_params)

'''
Parses a string potentially representing a roll. If the string is malformed, 
return an error message. If the string is a well-formed roll, convert it to 
a RollParams object. Then uses advantage to set the advantage state of the 
RollParams object and creates a RollResult object from it. Returns either an 
error message or the RollResult object converted to a string.
'''
def execute_roll_command(advantage: Advantage, roll_string) -> str:
    maybe_roll_params = parse_roll_string(roll_string)

    if not maybe_roll_params:
        return 'Your roll command was malformed. Please use the format \'<quantity>d<sides>[(+|-)<modifier>]\'.'
    else:
        maybe_roll_params.set_advantage(advantage)
        roll_result = make_roll(maybe_roll_params)
        return str(roll_result)

'''
Attempts to send a response to the server using the provided context. If 
an issue occurs during the send() call, catch it, log it, and send a 
follow-up message explaining that an error occurred.
'''
async def send_response(ctx, response_string: str):
    try:
        await ctx.send(response_string)
    except discord.errors.HTTPException as e:
        print (e)
        await ctx.send('The response generated by the bot was too long to send.')
    except Exception as e:
        print (e)
        await ctx.send('An error occurred while sending the response.')

@bot.event
async def on_ready():
    print(f'{bot.user.name} has connected to Discord!')

@bot.command(name='roll', help='Makes a roll with format \'<quantity>d<sides>[(+|-)<modifier>]\'')
async def roll(ctx, *, roll_string):
    await send_response(ctx, execute_roll_command(Advantage.NONE, roll_string))

@bot.command(name='advantage', help='Makes a roll with advantage')
async def roll_with_advantage(ctx, *, roll_string):
    await send_response(ctx, execute_roll_command(Advantage.ADVANTAGE, roll_string))

@bot.command(name='disadvantage', help='Makes a roll with disadvantage')
async def roll_with_disadvantage(ctx, *, roll_string):
    await send_response(ctx, execute_roll_command(Advantage.DISADVANTAGE, roll_string))

@bot.command(name='repeat', help='Repeats a roll the specified number of times')
async def repeat_roll(ctx, repetitions_string, *, roll_string):
    try:
        repetitions = int(repetitions_string)
    except Exception as e:
        print (e)
        await send_response(ctx, 'Your repeat command was malformed. Please use the format \'<repetitions> <quantity>d<sides>[(+|-)<modifier>]\'.')
        return
    
    maybe_roll_params = parse_roll_string(roll_string)
    if not maybe_roll_params:
        await send_response(ctx, 'Your roll command was malformed. Please use the format \'<quantity>d<sides>[(+|-)<modifier>]\'.')
        return
    
    roll_result_strings = []
    for _ in range(repetitions):
        roll_result_strings.append(execute_roll_command(Advantage.NONE, roll_string))
    
    await send_response(ctx, '\n'.join(roll_result_strings))


bot.run(DISCORD_TOKEN)